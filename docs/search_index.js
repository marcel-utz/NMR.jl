var documenterSearchIndex = {"docs":
[{"location":"Reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"Reference/#API","page":"Reference","title":"API","text":"","category":"section"},{"location":"Reference/","page":"Reference","title":"Reference","text":"Modules = [NMR, NMR.GISSMO, NMR.HMDB]\nOrder   = [:function, :type]","category":"page"},{"location":"Reference/#NMR.AutoPhaseCorrect-Tuple{Data1D}","page":"Reference","title":"NMR.AutoPhaseCorrect","text":"AutoPhaseCorrect(spect::Data1D; exclude=false,threshold=10)\n\nperforms zero- and first-order phase correction of spect using a the algorithm by van der Waals and Geerens, Journal of Magnetic Resonance 86 (1990) 127-154. It works by recognising the peaks in the magnitude mode spectrum and then representing the phase at each peak location through a linear regression.\n\nPassing a pair of indices to exclude disregards any peaks  between these two boundaries. This is useful in spectra that contain a solvent artefact that may not be phased correctly.\n\nthreshold defines a threshold for peak detection (cf. NMR.peaks()).\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.AutoPhaseCorrectChen-Tuple{Data1D}","page":"Reference","title":"NMR.AutoPhaseCorrectChen","text":"AutoPhaseCorrectChen(spect::Data1D;verbose=false) performs zero- and first-order phase correction of spect using a minimum entropy algorithm  by Chen et al. in Journal of Magnetic Resonance 158 (2002) 164–168. It uses the Nelder-Mead algorithm, as implemented in the Optim.jl package.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.BaseLineCorrect-Tuple{Data1D}","page":"Reference","title":"NMR.BaseLineCorrect","text":"Automatic Baseline Correction\n\nBaseLineCorrect(spect::Data1D;regions=128,kfactor=5,wdw=32) corrects the base line of spect using the algorithm by S. Golotvin, A. Williams, J. Magn. Reson. 146 (2000) 122-125.\n\nOptional Parameters:\n\nregions: the number of regions the spectrum is divided into to estimate  the noise variance. This should be chosen large enough so that at least one  of these regions is free from signals, and shows a flat baseline. The   variance sigma^2_min in this region is then used to distinguish signals and noise.\nwdw: the window size around each data point that is used to decide whether the data point is part of a signal, or should be counted as base line. \nkfactor: a point will be counted as part of the baseline if and only if the local variance in its window is less than kfactor*sigma^2_min.\noutput: defaults to :spectrum. output=:points will return an array of points, which indicate baseline positions (locations free from peaks) as determined by the algorithm. This is useful in situations where a large number of similar spectra need to be processed.\n\nNotes\n\nif the input data is complex, the imaginary part is ignored, and the result is always real.\nthe first and last point of spect are always used as part of the baseline.  The first and last points of the output are therefore guaranteed to be zero. This helps to keep the interpolation numerically stable.\n\nBaseline Correction With Known Locations\n\nBaseLineCorrect(spect::Data1D,pts::Array{Float64,1}) uses the points in pts to determine the baseline. This should be a list of positions in the spectrum that are known not to contain signal; it can be obtained by using the option output=:points in the first method of BaseLineCorrect(). \n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.FourierTransform-Tuple{Data1D}","page":"Reference","title":"NMR.FourierTransform","text":"FourierTransform(d::Data1DCTR=0.0, LB=0.0, SI=length(fid.dat), PPM=1,FFTSHIFT=true))\n\nperforms an FFT assuming that the input data set d is a free induction decay, and returns a DataSet object with the resulting complex data.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.FromXML-Tuple{LightXML.XMLElement}","page":"Reference","title":"NMR.FromXML","text":" FromXML(e::XMLElement)\n\nconverts XML representation to PeakStruct\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.PeakSpect-Tuple{Any, Any, Any}","page":"Reference","title":"NMR.PeakSpect","text":"function PeakSpect(p,i,r;lw=0.0001)\n\ncompute the the spectrum with Lorentzian peaks at locations given in array p and (complex) amplitudes in array i, over the range r, which can be either an array or a range. lwis the line width. AData1D` object is returned.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.PhaseCorrect-Tuple{Data1D}","page":"Reference","title":"NMR.PhaseCorrect","text":"PhaseCorrect(spect::Data1D;Ph0=0.0,Ph1=0.0,Pivot=0.0) returns a phase corrected DataSet, using the values indicated. The parameters are given in rad, k, and rad/k, where k are the units of the spectral domain (typically, Hz or ppm).\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.Spectrum-Tuple{Any, Any, Any}","page":"Reference","title":"NMR.Spectrum","text":"    function Spectrum(ρ,H,Ψ;tol=1e-3)\n\ncompute the frequencies and intensities of the spectrum given by the the initial density operator ρ, the Hamiltonian H, and the observation operator Ψ. The results are returned as a tuple (freq,int) of two one-dimensional arrays. tol is a cutoff; transitions with absolute amplitudes less than this value are suppressed.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.ToXML-Tuple{PeakStruct}","page":"Reference","title":"NMR.ToXML","text":"ToXML(p)\n\ngenerates an XML structure containing the peak intensities, positions, and widths contained in the PeakStruct p.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.clorentzian-Tuple{Float64, Float64, Float64}","page":"Reference","title":"NMR.clorentzian","text":"clorentzian(x0::Float64,σ::Float64,x::Float64)\n\nreturns the complex Lorentzian\n\nL(x) = sqrtsigmadfrac1+isqrtsigma(x-x_0)1+sigma(x-x_0)^2\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.derivative-Tuple{Data1D}","page":"Reference","title":"NMR.derivative","text":"derivative(spect::Data1D) computes the derivative of spect and returns it as another Data1D object\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.entropy-Tuple{Data1D}","page":"Reference","title":"NMR.entropy","text":"entropy(spect::Data1D) computes the entropy of the first derivative in the real part of an NMR spectrum as defined by Chen et al. in Journal of Magnetic Resonance 158 (2002) 164–168. This quantity can be optimised with respect to zero- and first-order phase correction for automatic (unsupervised) phase correction.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.hard_shift-Tuple{Data1D, Number}","page":"Reference","title":"NMR.hard_shift","text":"function hard_shift(d::Data1D,δ::Number)\n\nshifts the data in d by δ. The data is re-interpolated as needed. The resulting Data1D object is guaranteed to have the same index as d, such that they are compatible for the purposes of addition etc. Data shifted out of the  window is lost; data points shifted into view are set to zero.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.integral-Tuple{Data1D}","page":"Reference","title":"NMR.integral","text":"function integral(spect::Data1D)\n\ncomputes the numerical integral of spect by the trapezoid rule.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.integrate-Tuple{Data1D}","page":"Reference","title":"NMR.integrate","text":"function integrate(spect::Data1D,flip=true)\n\nintegrates the spectrum and returns the result as a Data1D object with the same horizontal axis.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.medianBaseline-Union{Tuple{Data1D{Tdata, Tindex}}, Tuple{Tindex}, Tuple{Tdata}} where {Tdata<:Real, Tindex}","page":"Reference","title":"NMR.medianBaseline","text":"function medianBaseline(s::NMR.Data1D;wdw=length(s)>>6)\n\nCompute baseline for the real part of s by the algorithm of M. S. Friedrichs, Journal of Biomolecular NMR,  5 (1995) 147  153. The window is automatically calculated as Deltaomega2^6, unless overridden by giving a value to the optional key wdw.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.peaks-Tuple{Data1D}","page":"Reference","title":"NMR.peaks","text":"peaks(dinput::Data1D;threshold=1,athresh=1,regions=128)\n\nidentifies the peaks in dinput. Peak positions are located roughly by searching for the downward zero crossings of the first derivative. The data points surrounding each peak are then used for a quadratic regression, from which the position, curvature, and height of the maximum are interpolated. The signal dinput is then decomposed into a linear superposition of Lorentzian peaks at the determined positions and with the determined curvatures.\n\npeaks() returns a PeakStruct data structure\n\nwhere positions and heights are the interpolated peak positions and heights, respectively; widths are the peak curvatures, which correspond to 1/FWHM line widths of the Lorentzian peaks. intensities are the peak intensities resulting from deconvolution. These values are proportional to the underlying concentrations in an NMR spectrum. Finally, deconvolution contains the deconvoluted approximation to the original input signal.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.readBrukerFID-Tuple{String}","page":"Reference","title":"NMR.readBrukerFID","text":"Bruker.readBrukerFID(s::String; format=Float64) reads a Bruker fid or ser file and returns the data contained in it as a complex array. For files generated by TopSpin 4.0 and higher, the default format (Float64) will work. For TopSpin 2.0, use format=Int32.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.readBrukerParameterFile-Tuple{String}","page":"Reference","title":"NMR.readBrukerParameterFile","text":"readBrukerParameterFile(s::String)\n\nreads a Bruker JCAMP-DX parameter file, and returns a dict with the values. Arrays such as D0 D1 D2 etc are returned as a Julia array. Note that the Bruker parameter D0 appears as param[\"D\"][1] due to Julia using 1-based arrays.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.shift-Tuple{PeakStruct, Real}","page":"Reference","title":"NMR.shift","text":"shift(p::PeakStruct,delta::Real)\n\nShift the positions of all peaks in p by delta\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.smooth","page":"Reference","title":"NMR.smooth","text":"smooth(d::Data1D,n=10)\n\nreturns a smoothed version of the input data set d, using convolution with a Gaussian peak.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#NMR.Data1D","page":"Reference","title":"NMR.Data1D","text":"Data1D(f<:AbstractArray,start<:Real,stop<:Real)\n\nreturns a data structure to hold a 1D NMR dataset either in the time or the frequency domain. Data1D objects store an index (range of time points or frequency points) along with the corresponding y-axis data. Data1D objects can be added and subtracted from one another, as long as their  indices match.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#NMR.PeakStruct","page":"Reference","title":"NMR.PeakStruct","text":"mutable struct PeakStruct\n\nData structure to hold a peak list.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#NMR.GISSMO.Hamiltonian-Tuple{String}","page":"Reference","title":"NMR.GISSMO.Hamiltonian","text":"function Hamiltonian(fn::String;freq=600.0,ctr=4.8)\nfunction Hamiltonian(system::XMLElement;freq=600.0,ctr=4.8)\n\ncomputes the Hamiltonian of an entry in the GISSMO database and returns it in the natural basis as a sparse matrix. fn is the GISSMO reference name of the compound. Keyword parameters are used to indicate spectrometer base frequency (in MHz) and the spectral zero point (carrier position) in ppm.  maxSpin represents the maximum size of the spin system that will be simulated. If the spin system size exceeds maxSpin, the function returns (-1,nothing).\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.GISSMO.search-Tuple{String}","page":"Reference","title":"NMR.GISSMO.search","text":"function search(term::String)\n\nsearches the online GISSMO database for term and returns a JSON object with the search result.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.HMDB.decompositionMatrix-Tuple{Any, Any}","page":"Reference","title":"NMR.HMDB.decompositionMatrix","text":"decompositionMatrix(names,range)\n\ncompute a decomposition matrix B such that B s  is the vector of concentrations of the metabolites listed in names. The pseudo-inverse is used for this purpose.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.HMDB.matchPeaks-Tuple{PeakStruct, NMR.HMDB.HMDBpeaks}","page":"Reference","title":"NMR.HMDB.matchPeaks","text":"(score,iscore,alpha,std) = matchPeaks(p::NMR.PeakStruct,ref::HMDBpeaks;tol=0.001)\n\nmatch the peaks in p to the reference ref. A tuple of four values is returned:\n\nscore: sum of the intensities of the peaks found, normalised by the height of the largest reference peak.  Missing peaks are counted as negative\niscore: score normalised by the total intensity of the reference peaks (range -1...1)\nalpha: fitted normalised concentration\nstd: mean error of fitted normalised concentration\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.HMDB.matchReport-Tuple{PeakStruct}","page":"Reference","title":"NMR.HMDB.matchReport","text":"xml=matchReport(p::NMR.PeakStruct,tol=0.01,AutoShift=true,iscoreCutoff=0,Id=\"\",verbose=true)\n\nmatch peaks in p against all metabolites in HMDB.refPeaks, and create a table of the results. If AutoShift is set to true (default), the p is automatically shfited for the greatest overlap with D-Glucose. tol is the matching tolerance for peak identification. Metabolites with iscores below iscoreCutoff are not reported. Metabolites are listed in decreasing order of concentration. matchReport() returns an XML object containing the listed data. Id is incorporated into the XML object as an attribute, to facilitate later identification of the match report.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#NMR.HMDB.refSpectrum-Tuple{String, Vector{Float64}}","page":"Reference","title":"NMR.HMDB.refSpectrum","text":"s::Data1D = refSpectrum(name::String,range;lw=0.01)\n\ncompute a reference spectrum over range using the peak positions in reference spectrum name. A Lorentzian line with half width lw is used. The reference spectrum is returned as a real Data1D object, unless the option complex=true is given.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"Reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"NMR-1.0/#Roadmap-to-Version-1.0","page":"Roadmap to Version 1.0","title":"Roadmap to Version 1.0","text":"","category":"section"},{"location":"NMR-1.0/","page":"Roadmap to Version 1.0","title":"Roadmap to Version 1.0","text":"This is a roadmap towards publishing NMR.jl first for internal use, and then  to the wider community.","category":"page"},{"location":"NMR-1.0/","page":"Roadmap to Version 1.0","title":"Roadmap to Version 1.0","text":"In its current state, NMR.jlis a package of tools that have been designed for only internal use. Most of it is not properly documented. The data structures have not been thought through carefully, but have mostly just grown as things went along.","category":"page"},{"location":"NMR-1.0/","page":"Roadmap to Version 1.0","title":"Roadmap to Version 1.0","text":"For professional use, a few requirements are imperative:","category":"page"},{"location":"NMR-1.0/","page":"Roadmap to Version 1.0","title":"Roadmap to Version 1.0","text":"good documentation, including a set of example data\nclean integration into the Julia universe\nData types\nPlots\nInput and output; IJulia etc\nwell thought-out NMRData type\nseamless integration of spectral analysis and simulation tools\nloading multiple vendor data formats\nproper handling of metadata","category":"page"},{"location":"NMR-1.0/","page":"Roadmap to Version 1.0","title":"Roadmap to Version 1.0","text":"The current roadmap for development is shown in the following table:","category":"page"},{"location":"NMR-1.0/","page":"Roadmap to Version 1.0","title":"Roadmap to Version 1.0","text":"Version Planned features Target release date\n0.9.0 cleanup, document basic functionality, how-to documentation for simple spectral processing 22.1.2025\n0.10.0 new data structures, transform, plots 31.1.2025\n0.11.0 new vendor and metadata support 28.2.2025\n0.12.0 integration of AI processing 31.3.2025\n0.13.0 complete documentation 15.4.2025","category":"page"},{"location":"#NMR.jl","page":"NMR.jl","title":"NMR.jl","text":"","category":"section"},{"location":"","page":"NMR.jl","title":"NMR.jl","text":"A set of tools for processing, plotting, and interpreting NMR data","category":"page"},{"location":"#Package-Features","page":"NMR.jl","title":"Package Features","text":"","category":"section"},{"location":"","page":"NMR.jl","title":"NMR.jl","text":"Reading and processing NMR data from JEOL, Bruker, and Varian/Agilent Spectrometers\nSimulations of Spin dynamics based on efficient sparse matrix representations of the spin Hamiltonian and density operator\nSome specialised and advanced tools for data interpretation in the context of metabolomics","category":"page"},{"location":"#Contents","page":"NMR.jl","title":"Contents","text":"","category":"section"},{"location":"","page":"NMR.jl","title":"NMR.jl","text":"","category":"page"},{"location":"","page":"NMR.jl","title":"NMR.jl","text":"NMR.jl is a library of tools for the processing, plotting, and interpretation of NMR data. The project started out as an internal quick-and-dirty set of tools in the Utz research laboratory at the University of Southampton. At the time, Julia was in a very early stage, and its use was experimental. In the meantime, a sizeable number of research projects have been carried out in the group using early versions of NMR.jl, and it seemed like a good idea to complete the tools and the documentation, and make the package available to the community.","category":"page"},{"location":"","page":"NMR.jl","title":"NMR.jl","text":"note: Applications\nNMR.jl is intended to be applicable to any kind of NMR data, and aims at implementing a broad set of features to enable even advanced NMR data processing. Some of its functionality is designed for convenience, making everyday tasks  accessible with a reasonable default set of parameters. Power users may want to use the more low-level routines, which are underlying the high-level interface.","category":"page"},{"location":"#Manual-Outline","page":"NMR.jl","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"NMR.jl","title":"NMR.jl","text":"If you would like to jump right in, read the Getting started section. For a more in-depth and complete documentation, refer to the Manual. Finally, a complete list and documentation of every function  can be found under API.","category":"page"},{"location":"#Feedback","page":"NMR.jl","title":"Feedback","text":"","category":"section"},{"location":"","page":"NMR.jl","title":"NMR.jl","text":"NMR.jlis still under active development, and we would appreciate your feedback, including feature requests, bug reports, and general comments. Please contact marcel.utz@kit.edu by email.","category":"page"},{"location":"#Citing-NMR.jl","page":"NMR.jl","title":"Citing NMR.jl","text":"","category":"section"},{"location":"","page":"NMR.jl","title":"NMR.jl","text":"If you publish your work and have been using NMR.jl to process, present, and/or interpret your data, we would appreciate if you could acknowledge this by citing our work. The reference is TBA.","category":"page"},{"location":"Manual/#User-Manual","page":"User Manual","title":"User Manual","text":"","category":"section"},{"location":"Manual/#Getting-started","page":"User Manual","title":"Getting started","text":"","category":"section"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"NMR.jl is a Julia package. It is installed using the Julia package management system:","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"import Pkg\nPkg.add(url=\"https://github.com/marcel-utz/NMR.jl\")","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"Once the install finishes, you are ready to go.","category":"page"},{"location":"Manual/#Loading-NMR-Data","page":"User Manual","title":"Loading NMR Data","text":"","category":"section"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"To start processing, you need to load some NMR data. There are commands to load raw data from various spectrometer vendors. Typically, the data is loaded raw. This means that only the time-domain spectral data is returned, and you have to manually convert it to a data object that can be further processed.","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"Here is an example:","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nimport NMR\nimport Plots # hide\n\nf=NMR.readBrukerFID(\"../../test/data/10/fid\")","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"freturns an array with the complex data points contained in the  fid file. To convert this to useable time-domain data,  you need to convert it into a Data1D object. ","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"Bruker NMR systems store the acquisition parameters in a separate file, which we can read into a Julia dictionary as follows:","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"acqus=NMR.readBrukerParameterFile(\"../../test/data/10/acqus\")","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"To convert the raw fid data into a Data1D object which we can process,  we need some of these parameters. The time step between subsequent points in the FID is given by the inverse of the spectral width. Moreover, Bruker FIDs actually begin before t=0. We have to remove these points:","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"dwellTime=1/acqus[\"SW_h\"]\nf=f[74:end]\nd=NMR.Data1D(f,0.0,length(f)*dwellTime)\nNMR.plot(real(d))\nPlots.savefig(\"plot-fid.svg\"); nothing # hide","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"(Image: )","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"To convert the time-domain data into a spectrum, we use NMR.FourierTransform. By default, FourierTransform interprets the time domain in the Data1D object in seconds, and produces another Data1D object with a horizontal axis in Hz:","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"import Plots\nspect=NMR.FourierTransform(d)\nPlots.plot(real(spect),xaxis=:flip,xlabel=\"frequency [Hz]\")\nPlots.savefig(\"plot-spec.svg\"); nothing # hide","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"(Image: )","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"To obtain a spectrum with a horizontal axis in ppm chemical shift, we have  to indicate the conversion. This is done by giving the number of Hz per ppm  as a parameter. In our case, the spectrum was acquired on a 700 MHz spectrometer. One ppm therefore corresponds to 700 Hz. The precise factor is contained in the Bruker parameter \"SFO1\". Also, we can calibrate the horizontal axis by indicating the chemical shift at the centre of the spectrum:","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"import Plots\nspect=NMR.FourierTransform(d,PPM=acqus[\"SFO1\"],CTR=4.76)\nPlots.plot(real(spect),xaxis=:flip,xlabel=\"1H Chem. Shift [ppm]\")\nPlots.savefig(\"plot-specHz.svg\"); nothing # hide","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"(Image: )","category":"page"},{"location":"Manual/#Phase-Correction","page":"User Manual","title":"Phase Correction","text":"","category":"section"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"The above spectrum still shows artefacts. To clean it up, we need to correct the phase. This can either be done manually, by supplying PH0and PH1 arguments to FourierTransform, or we can resort to automatic phase correction:","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"spect = NMR.AutoPhaseCorrectChen(spect)\nPlots.plot(real(spect),xaxis=:flip,xlabel=\"1H Chem. Shift [ppm]\")\nPlots.savefig(\"plot-specHz-ap.svg\"); nothing # hide","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"(Image: )","category":"page"},{"location":"Manual/#Cutting-Regions","page":"User Manual","title":"Cutting Regions","text":"","category":"section"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"The above spectrum covers a wide range without any signals, which is of no interest. We can chop out the central, important part:","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"s2=NMR.cut(spect,-0.5,7.0)\nPlots.plot(real(s2),xaxis=:flip,xlabel=\"1H Chem. Shift [ppm]\")\nPlots.savefig(\"plot-S2.svg\"); nothing # hide","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"(Image: )","category":"page"},{"location":"Manual/#Computing-Integrals","page":"User Manual","title":"Computing Integrals","text":"","category":"section"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"In Chemistry, it is customary to show the integral of the spectral signal along with the spectrum. This makes the intensity of the peaks directly visible as a step height for each signal. The integrated spectrum can be computed like this:","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"intSpect = NMR.integrate(s2)\nPlots.plot(real(s2),xaxis=:flip,xlabel=\"1H Chem. Shift [ppm]\",label=\"spectrum\")\nPlots.plot!(20*intSpect,label=\"integral\")\nPlots.savefig(\"plot-S3.svg\"); nothing # hide","category":"page"},{"location":"Manual/","page":"User Manual","title":"User Manual","text":"(Image: )","category":"page"}]
}
